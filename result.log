ft_memset:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_bzero:      [OK] [OK] [OK] [OK] 
ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memccpy:    [MISSING]
ft_memmove:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memcmp:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_isalpha:    [OK] 
ft_isdigit:    [OK] 
ft_isalnum:    [OK] 
ft_isascii:    [OK] 
ft_isprint:    [OK] 
ft_toupper:    [OK] 
ft_tolower:    [OK] 
ft_strchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strrchr:    [OK] [OK] [OK] [FAILED] [FAILED] [OK] [OK] [OK] 
[fail]: your strrchr does not work with unicode
Test code:
	char *src = "īœ˙ˀ˘¯ˇ¸¯.œ«‘––™ª•¡¶¢˜ˀ";
	char *d1 = strrchr(src, L'–');
	char *d2 = ft_strrchr(src, L'–');

	if (d1 == d2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strrchr: |(null)|
  ft_strrchr: |īœ˙ˀ˘¯ˇ¸¯.œ«‘––™ª•¡¶¢˜ˀ|

[fail]: your strrchr does not work with \0
Test code:
	char *src = "there is so \0ma\0ny \0 \\0 in t\0his stri\0ng !\0\0\0\0";
	char *d1 = strrchr(src, '\0');
	char *d2 = ft_strrchr(src, '\0');

	if (d1 == d2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strrchr: ||
  ft_strrchr: ||

ft_strncmp:    [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [FAILED] [FAILED] [OK] [OK] [OK] 
[fail]: your strncmp does not cast in unsigned char the diff
Test code:
	char *s1 = "\200";
	char *s2 = "\0";
	int i1 = ((strncmp(s1, s2, 1) > 0) ? 1 : ((strncmp(s1, s2, 1) < 0) ? -1 : 0));
	int i2 = ((ft_strncmp(s1, s2, 1) > 0) ? 1 : ((ft_strncmp(s1, s2, 1) < 0) ? -1 : 0));

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncmp: |1|
  ft_strncmp: |-1|

[fail]: your strncmp does not work with non ascii chars
Test code:
	char *s1 = "\x12\xff\x65\x12\xbd\xde\xad";
	char *s2 = "\x12\x02";
	size_t size = 6;
	int i1 = ((strncmp(s1, s2, size) > 0) ? 1 : ((strncmp(s1, s2, size) < 0) ? -1 : 0));
	int i2 = ((ft_strncmp(s1, s2, size) > 0) ? 1 : ((ft_strncmp(s1, s2, size) < 0) ? -1 : 0));

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncmp: |1|
  ft_strncmp: |-1|

[fail]: your strncmp does not work when s1 is contained in s2
Test code:
	char *big = "abcdef";
	char *little = "abcdefghijklmnop";
	size_t size = 6;
	int i1 = ((strncmp(big, little, size) > 0) ? 1 : ((strncmp(big, little, size) < 0) ? -1 : 0));
	int i2 = ((ft_strncmp(big, little, size) > 0) ? 1 : ((ft_strncmp(big, little, size) < 0) ? -1 : 0));

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncmp: |0|
  ft_strncmp: |-1|

ft_strlcpy:    [OK] [OK] [FAILED] [FAILED] [FAILED] [FAILED] [OK] 
[fail]: your strlcpy overflow the dest
Test code:
	char *str = "BBBB";
	char buff1[0xF00];
	char buff2[0xF00];

	__builtin___memset_chk (buff1, 'A', 20, __builtin_object_size (buff1, 0));
	__builtin___memset_chk (buff2, 'A', 20, __builtin_object_size (buff2, 0));
	__builtin___strlcpy_chk (buff1, str, sizeof(buff1), __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strlcpy(buff2, str, sizeof(buff2));
	if (!memcmp(buff1, buff2, 20))
		exit(TEST_SUCCESS);
	for (register int __i = 0; __i < 20; ++__i)
	for (register int __i = 0; __i < 20; ++__i)
	exit(TEST_FAILED);

Diffs:
     strlcpy: |\x42 \x42 \x42 \x42 \x0  \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 |
  ft_strlcpy: |\x42 \x42 \x42 \x42 \x0  \x79 \x6f \x75 \x72 \x20 \x73 \x74 \x72 \x6c \x63 \x70 \x79 \x20 \x64 \x6f |

[fail]: your strlcpy does works whe size < strlen(src)
Test code:
	char *str = "hello !";
	char buff1[0xF00];
	char buff2[0xF00];
	size_t r1;
	size_t r2;

	__builtin___memset_chk (buff1, 'A', 20, __builtin_object_size (buff1, 0));
	__builtin___memset_chk (buff2, 'A', 20, __builtin_object_size (buff2, 0));
	r1 = __builtin___strlcpy_chk (buff1, str, 2, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	r2 = ft_strlcpy(buff2, str, 2);
	if (r1 == r2 && !memcmp(buff1, buff2, 20))
		exit(TEST_SUCCESS);
	if (r1 != r2)
	{
	}
		for (register int __i = 0; __i < 20; ++__i)
		for (register int __i = 0; __i < 20; ++__i)
	}
	exit(TEST_FAILED);

Diffs:
     strlcpy: |7|
  ft_strlcpy: |1|

[fail]: your strlcpy does not works with 0-length string
Test code:
	char *str = "";
	char buff1[0xF00];
	char buff2[0xF00];
	size_t r1;
	size_t r2;

	__builtin___memset_chk (buff1, 'A', 20, __builtin_object_size (buff1, 0));
	__builtin___memset_chk (buff2, 'A', 20, __builtin_object_size (buff2, 0));
	r1 = __builtin___strlcpy_chk (buff1, str, sizeof(buff1), __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	r2 = ft_strlcpy(buff2, str, sizeof(buff2));
	if (r1 == r2 && !memcmp(buff1, buff2, 20))
		exit(TEST_SUCCESS);
	if (r1 != r2)
	{
	}
		for (register int __i = 0; __i < 20; ++__i)
		for (register int __i = 0; __i < 20; ++__i)
	}
	exit(TEST_FAILED);

Diffs:
     strlcpy: |\x0  \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 |
  ft_strlcpy: |\x0  \x0  \x0  \x0  \x0  \x0  \x0  \x0  \x74 \x65 \x73 \x74 \x20 \x62 \x61 \x73 \x69 \x63 \x20 \x64 |

[fail]: your strlcpy copies while destsize is zero, or does not return the size of the string it tried to create
Test code:
	char *str = "BBBB";
	char buff1[0xF00];
	char buff2[0xF00];

	__builtin___memset_chk (buff1, 'A', 20, __builtin_object_size (buff1, 0));
	__builtin___memset_chk (buff2, 'A', 20, __builtin_object_size (buff2, 0));
	if (__builtin___strlcpy_chk (buff1, str, 0, __builtin_object_size (buff1, 2 > 1 ? 1 : 0)) != ft_strlcpy(buff2, str, 0))
		exit(TEST_FAILED);
	if (!memcmp(buff1, buff2, 20))
		exit(TEST_SUCCESS);
	for (register int __i = 0; __i < 20; ++__i)
	for (register int __i = 0; __i < 20; ++__i)
	exit(TEST_FAILED);

Diffs:


ft_strlcat:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] [CRASH] 
[fail]: your strlcat does not set a \0 to the end
Test code:
	char *str = "n\0AA";
	char buff1[0xF00] = "\0AAAAAAAAAAAAAAAA";
	char buff2[0xF00] = "\0AAAAAAAAAAAAAAAA";
	size_t max = 10;

	__builtin___strlcat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strlcat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |n|
  ft_strlcat: |nAAAAAAAAAAAAAAAA|

[crash]: your strlcat crush when null parameter is sent with a size of 0
Test code:
	char b[0xF] = "nyan !";

	ft_strlcat(((void *)0), b, 0);
	exit(TEST_SUCCESS);


ft_strnstr:    [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] [FAILED] [OK] [OK] [OK] [CRASH] 
[fail]: your strnstr does not work with basic input
Test code:
	char *s1 = "see FF your FF return FF now FF";
	char *s2 = "FF";
	size_t max = strlen(s1);
	char *i1 = strnstr(s1, s2, max);
	char *i2 = ft_strnstr(s1, s2, max);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strnstr: |FF your FF return FF now FF|
  ft_strnstr: |e FF your FF return FF now FF|

[fail]: your strnstr does not work with the same pointer "little" string
Test code:
	char *s1 = "AAAAAAAAAAAAA";
	size_t max = strlen(s1);
	char *i1 = strnstr(s1, s1, max);
	char *i2 = ft_strnstr(s1, s1, max);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strnstr: |AAAAAAAAAAAAA|
  ft_strnstr: ||

[fail]: your strnstr does not work with the same pointer and an exceeding length value
Test code:
	char *s1 = "A";
	size_t max = strlen(s1) + 1;
	char *i1 = strnstr(s1, s1, max);
	char *i2 = ft_strnstr(s1, s1, max);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strnstr: |A|
  ft_strnstr: ||

[crash]: your strnstr crush when null parameter is sent with a size of 0
Test code:
	ft_strnstr(((void *)0), "fake", 0);

	exit(TEST_SUCCESS);


ft_atoi:       [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [KO] [KO] [OK] [OK] [OK] [OK] 
[KO]: your atoi does not work with over long max value
Test code:
	char n[40] = "99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |-1|
     ft_atoi: |-469762049|

[KO]: your atoi does not work with over long min value
Test code:
	char n[40] = "-99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |0|
     ft_atoi: |469762049|

ft_calloc:     [OK] [OK] [OK] [OK] [OK] 
ft_strdup:     [CRASH] [OK] [CRASH] [OK] [OK] [OK] [OK] 
[crash]: you didn't protect your malloc return
Test code:
	char *ptr;

	ptr = ft_strdup("lol");
	if (!ptr)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[crash]: your strdup don't work with empty string
Test code:
	char *str;
	char *tmp = "";

	str = ft_strdup(tmp);
	if (strcmp(str, tmp))
		exit(TEST_FAILED);
	free(str);
	exit(TEST_SUCCESS);


ft_substr:     [MISSING]
ft_strjoin:    [MISSING]
ft_strtrim:    [MISSING]
ft_split:      [MISSING]
ft_itoa:       [MISSING]
ft_strmapi:    [MISSING]
ft_putchar_fd: [MISSING]
ft_putstr_fd:  [MISSING]
ft_putendl_fd: [MISSING]
ft_putnbr_fd:  [MISSING]
ft_lstnew:     [MISSING]
ft_lstadd_front: [MISSING]
ft_lstsize:    [MISSING]
ft_lstlast:    [MISSING]
ft_lstadd_back:[MISSING]
ft_lstdelone:  [MISSING]
ft_lstclear:   [MISSING]
ft_lstiter:    [MISSING]
ft_lstmap:     [MISSING]
